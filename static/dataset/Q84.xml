<?xml version="1.0" encoding="ISO-8859-1"?>
<content>
	<skill kind="detailed">python_behavior</skill>
	<description>
		Predicting the possible outcomes of program (2017 Spring, Final, Question 9 b)
	</description>
	<question>
		<p>
			<line>We've always appreciated how easily Python handles functions as data. There's no _BOLDS_call, run_BOLDE_ or _BOLDS_launch_BOLDE_ block, you can just receive a function as a parameter and call it directly. This gives us an idea. You remember when we talked in lecture about how _BOLDS_combine_BOLDE_ should always work if you're given an associative dyadic (twoinput) function, and how it paired its values up was below the abstraction line (i.e., you shouldn't know about it)? It could evaluate it any way it wants and the answer should still be the same. For example, if given + on a list of 5 elements A through E, it could return ((((A+B)+C)+D)+E) or ((A + ((B + C) + D)) + E) etc, and it will all work because + is an associative dyadic function. Taking that to heart, we've rewritten _BOLDS_combine_BOLDE_ (as _BOLDS_mycombine_BOLDE_) below that finds a random adjacent pair of elements, calls its function _BOLDS_f_BOLDE_ on them and puts the result back in line:</line>
			<line>(note _BOLDS_randint_BOLDE_ below is inclusive of its endpoints, so _BOLDS_randint(1, 3)_BOLDE_ might return 1,2, or 3)</line>
			<line> </line>
			<line>_BOLDS_def mycombine(f,data):_BOLDE_</line>
			<line>_BOLDS__BLANK__BLANK_L = data[:] _BOLDE_## make a copy of the input</line>
			<line>_BOLDS__BLANK__BLANK_while len(L) _GT_ 1: _BOLDE_ ## until we're done,i.e. list==[elt]</line>
			<line>_BOLDS__BLANK__BLANK__BLANK__BLANK_index = random.randint(0,len(L)-2) _BOLDE_ ## pick a random index (not the end)</line>
			<line>_BOLDS__BLANK__BLANK__BLANK__BLANK_L[index]=f(L[index],L[index+1]) _BOLDE_ ## replace element with call to f</line>
			<line>_BOLDS__BLANK__BLANK__BLANK__BLANK_L.pop(index+1) _BOLDE_ ## delete the one to the right</line>
			<line>_BOLDS__BLANK__BLANK_return L[0] _BOLDE_ ## return the listâ€™s only element</line>
			<line> _BOLDS_ </line>
			<line>def joinswap(x,y):</line>
			<line>_BLANK__BLANK_return int(str(y)+str(x))</line>
			<line> _BOLDE_ </line>
			<line>What will be _BOLDS_mycombine(joinswap,[1,2,3])_BOLDE_ return if _BOLDS_randint_BOLDE_ always returns _BOLDS_len(L)-2_BOLDE_ (i.e., always picks the all-but-rightmost index)? (select ONE)</line>
		</p>
	</question>
	<answers>
		<option id="c1">
			<p>
				<line>123</line>
			</p>
		</option>
		<option id="c2">
			<p>
				<line>132</line>
			</p>
		</option>
		<option id="c3">
			<p>
				<line>213</line>
			</p>
		</option>
		<option id="c4">
			<p>
				<line>231</line>
			</p>
		</option>
		<option id="c5">
			<p>
				<line>312</line>
			</p>
		</option>
		<option id="c6" correct="true">
			<p>
				<line>321</line>
			</p>
		</option>
		<option id="c7">
			<p>
				<line>Error</line>
			</p>
		</option>
		<option id="c8">
			<p>
				<line>None of these</line>
			</p>
		</option>

	</answers>
	<hint>Consider the function joinswap. It swaps while joins.</hint>
</content>